// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package version

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
)

// RunTag runs a tagged version of the "go" tool from the development tree.
func RunTag(tag string) {
	log.SetFlags(0)

	if tag == "" {
		tag = "gotip-embedded"
	}

	root, err := goroot(tag)
	if err != nil {
		log.Fatalf("%s: %v", tag, err)
	}

	if len(os.Args) > 1 && os.Args[1] == "download" {
		switch len(os.Args) {
		case 2:
			if err := installTip(root, tag); err != nil {
				log.Fatalf("%s: %v", tag, err)
			}
		default:
			log.Fatalf("%s: usage: %s download", tag, tag)
		}
		log.Printf("Success. You may now run '%s'!", tag)
		os.Exit(0)
	}

	gobin := filepath.Join(root, "bin", "go"+exe())
	if _, err := os.Stat(gobin); err != nil {
		log.Fatalf("%s: not downloaded. Run '%s download' to install to %v", tag, tag, root)
	}

	runGo(root)
}

// RunTip runs the "go" tool from the development tree.
func RunTip() {
	log.SetFlags(0)

	root, err := goroot("gotip-embedded")
	if err != nil {
		log.Fatalf("gotip-embedded: %v", err)
	}

	if len(os.Args) > 1 && os.Args[1] == "download" {
		switch len(os.Args) {
		case 2:
			if err := installTip(root, ""); err != nil {
				log.Fatalf("gotip-embedded: %v", err)
			}
		case 3:
			if err := installTip(root, os.Args[2]); err != nil {
				log.Fatalf("gotip-embedded: %v", err)
			}
		default:
			log.Fatalf("gotip-embedded: usage: gotip download [branch name]")
		}
		log.Printf("Success. You may now run 'gotip-embedded'!")
		os.Exit(0)
	}

	gobin := filepath.Join(root, "bin", "go"+exe())
	if _, err := os.Stat(gobin); err != nil {
		log.Fatalf("gotip-embedded: not downloaded. Run 'gotip-embedded download' to install to %v", root)
	}

	runGo(root)
}

func installTip(root, target string) error {
	git := func(args ...string) error {
		cmd := exec.Command("git", args...)
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Dir = root
		cmd.Env = dedupEnv(caseInsensitiveEnv, append(os.Environ(), "PWD="+cmd.Dir))
		return cmd.Run()
	}

	if _, err := os.Stat(filepath.Join(root, ".git")); err != nil {
		if err := os.MkdirAll(root, 0755); err != nil {
			return fmt.Errorf("failed to create repository: %v", err)
		}
		if err := git("clone", "--origin=origin", "--depth=1", "https://www.github.com/clktmr/go.git", root); err != nil {
			return fmt.Errorf("failed to clone git repository: %v", err)
		}
	}

	if target != "" {
		log.Printf("Fetching branch %v...", target)
		if err := git("fetch", "origin", target); err != nil {
			return fmt.Errorf("failed to fetch %s: %v", target, err)
		}
	} else {
		log.Printf("Updating the go development tree...")
		if err := git("fetch", "origin", "master-embedded"); err != nil {
			return fmt.Errorf("failed to fetch git repository updates: %v", err)
		}
	}

	// Use checkout and a detached HEAD, because it will refuse to overwrite
	// local changes, and warn if commits are being left behind, but will not
	// mind if master is force-pushed upstream.
	if err := git("-c", "advice.detachedHead=false", "checkout", "FETCH_HEAD"); err != nil {
		return fmt.Errorf("failed to checkout git repository: %v", err)
	}
	// It shouldn't be the case, but in practice sometimes binary artifacts
	// generated by earlier Go versions interfere with the build.
	//
	// Ask the user what to do about them if they are not gitignored. They might
	// be artifacts that used to be ignored in previous versions, or precious
	// uncommitted source files.
	if err := git("clean", "-i", "-d"); err != nil {
		return fmt.Errorf("failed to cleanup git repository: %v", err)
	}
	// Wipe away probably boring ignored files without bothering the user.
	if err := git("clean", "-q", "-f", "-d", "-X"); err != nil {
		return fmt.Errorf("failed to cleanup git repository: %v", err)
	}

	cmd := exec.Command(filepath.Join(root, "src", makeScript()))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Dir = filepath.Join(root, "src")
	// Add new GOROOT/bin to PATH to silence path warning at end of make.bash.
	// Add PWD to environment to fix future calls to os.Getwd.
	newPath := filepath.Join(root, "bin")
	if p := os.Getenv("PATH"); p != "" {
		newPath += string(filepath.ListSeparator) + p
	}
	cmd.Env = dedupEnv(caseInsensitiveEnv, append(os.Environ(), "PATH="+newPath, "PWD="+cmd.Dir))

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to build go: %v", err)
	}

	return nil
}

func makeScript() string {
	switch runtime.GOOS {
	case "plan9":
		return "make.rc"
	case "windows":
		return "make.bat"
	default:
		return "make.bash"
	}
}
